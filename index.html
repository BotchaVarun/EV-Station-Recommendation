<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EV Station Navigator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --color-background: rgba(252, 252, 249, 1);
            --color-surface: rgba(255, 255, 253, 1);
            --color-text: rgba(19, 52, 59, 1);
            --color-primary: rgba(33, 128, 141, 1);
            --color-error: rgba(192, 21, 47, 1);
            --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --space-16: 16px;
            --space-8: 8px;
            --radius-base: 8px;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --color-background: rgba(31, 33, 33, 1);
                --color-surface: rgba(38, 40, 40, 1);
                --color-text: rgba(245, 245, 245, 1);
                --color-primary: rgba(50, 184, 198, 1);
                --color-error: rgba(255, 84, 89, 1);
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family-base);
            background-color: var(--color-background);
            color: var(--color-text);
            padding: var(--space-16);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: var(--space-16);
            color: var(--color-text);
        }

        #map {
            height: 500px;
            width: 100%;
            border-radius: var(--radius-base);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .info-panel {
            background-color: var(--color-surface);
            padding: var(--space-16);
            margin-top: var(--space-16);
            border-radius: var(--radius-base);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .status {
            display: inline-block;
            padding: var(--space-8) 12px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.loading {
            background-color: rgba(33, 128, 141, 0.15);
            color: var(--color-primary);
        }

        .status.error {
            background-color: rgba(192, 21, 47, 0.15);
            color: var(--color-error);
        }

        .status.success {
            background-color: rgba(33, 128, 141, 0.15);
            color: var(--color-primary);
        }

        .coords {
            margin-top: var(--space-8);
            font-size: 14px;
            color: var(--color-text);
            opacity: 0.8;
        }

        .input-group {
            margin-bottom: var(--space-16);
        }

        label {
            display: block;
            margin-bottom: var(--space-8);
            font-weight: 500;
            font-size: 14px;
        }

        input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(94, 82, 64, 0.2);
            border-radius: var(--radius-base);
            font-family: var(--font-family-base);
            font-size: 14px;
            background-color: var(--color-surface);
            color: var(--color-text);
            transition: border-color 0.2s;
        }

        input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .btn {
            padding: 12px 24px;
            background-color: var(--color-primary);
            color: white;
            border: none;
            border-radius: var(--radius-base);
            font-family: var(--font-family-base);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
            margin-right: var(--space-8);
            margin-bottom: var(--space-8);
        }

        .btn:hover {
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: rgba(33, 128, 141, 0.15);
            color: var(--color-primary);
        }

        .btn-warning {
            background-color: rgba(230, 129, 97, 0.2);
            color: rgba(168, 75, 47, 1);
        }

        .controls {
            background-color: var(--color-surface);
            padding: var(--space-16);
            margin-bottom: var(--space-16);
            border-radius: var(--radius-base);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .route-info {
            margin-top: var(--space-8);
            padding: 12px;
            background-color: rgba(33, 128, 141, 0.1);
            border-radius: var(--radius-base);
            font-size: 14px;
        }

        @media (prefers-color-scheme: dark) {
            input {
                border-color: rgba(119, 124, 124, 0.3);
            }
            .btn-warning {
                background-color: rgba(230, 129, 97, 0.15);
                color: rgba(230, 129, 97, 1);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EV Station Navigator</h1>
        
        <!-- ROUTE PLANNING SECTION -->
        <div class="controls">
            <h3>Route Planning & Stations Along Route</h3>
            <div class="input-group">
                <label for="source">Source Location (or leave empty to use current location)</label>
                <input type="text" id="source" placeholder="Enter source address or coordinates (lat, lng)">
            </div>

            <div class="input-group">
                <label for="destination">Destination Location *</label>
                <input type="text" id="destination" placeholder="Enter destination address or coordinates (lat, lng)" required>
            </div>

            <button class="btn" id="navigateBtn">Get Directions</button>
            <button class="btn btn-secondary" id="clearRouteBtn">Clear Route</button>

            <div id="routeInfo" class="route-info" style="display: none;"></div>
        </div>

        <!-- NEARBY STATIONS SECTION -->
        <div class="controls">
            <h3>Nearby Station Finder</h3>
            <div class="input-group">
                <label for="nearbySearchLocation">Search Location (leave empty for current location)</label>
                <input type="text" id="nearbySearchLocation" placeholder="Enter address or coordinates (lat, lng)">
            </div>

            <button class="btn" id="findNearbyBtn">Find Nearby Stations (5km)</button>
            <button class="btn btn-warning" id="findAllIndiaBtn">Show All Stations in India</button>
            <button class="btn btn-secondary" id="clearStationsBtn">Clear Stations</button>

            <div id="stationsPanel" class="route-info" style="display: none; max-height: 260px; overflow-y: auto;">
                <strong>EV Charging Stations:</strong>
                <div id="stationsList"></div>
            </div>
        </div>

        <div id="map"></div>
        
        <div class="info-panel">
            <div id="status" class="status loading">Initializing...</div>
            <div id="coords" class="coords"></div>
        </div>
    </div>

    <script>
        // Globals
        let map;
        let currentMarker;
        let sourceMarker;
        let destinationMarker;
        let routeLine;
        let userLocation = null;
        let stationMarkers = [];
        let stationsData = []; // Loaded from CSV

        const statusEl = document.getElementById('status');
        const coordsEl = document.getElementById('coords');
        const sourceInput = document.getElementById('source');
        const destinationInput = document.getElementById('destination');
        const navigateBtn = document.getElementById('navigateBtn');
        const clearRouteBtn = document.getElementById('clearRouteBtn');
        const routeInfo = document.getElementById('routeInfo');
        const findNearbyBtn = document.getElementById('findNearbyBtn');
        const findAllIndiaBtn = document.getElementById('findAllIndiaBtn');
        const clearStationsBtn = document.getElementById('clearStationsBtn');
        const stationsPanel = document.getElementById('stationsPanel');
        const stationsList = document.getElementById('stationsList');
        const nearbySearchInput = document.getElementById('nearbySearchLocation');

        // Initialize map
        map = L.map('map').setView([20, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Custom EV icon (uploaded file name should be present in same folder)
        const evIcon = L.icon({
            iconUrl: 'https://delicate-coral-l9qpqbatby-lhsqo9f352.edgeone.dev/ev_station_logo-removebg-preview.png',
            iconSize: [60, 60],
            iconAnchor: [20, 40],
            popupAnchor: [0, -38]
        });

        // User/source/destination icons remain as before
        const greenIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        const redIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        // Geolocation
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(function(position) {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;
                userLocation = { lat, lng };
                map.setView([lat, lng], 13);
                currentMarker = L.marker([lat, lng]).addTo(map)
                    .bindPopup('<b>Your Current Location</b>').openPopup();
                L.circle([lat, lng], { radius: accuracy }).addTo(map);
                statusEl.className = 'status success';
                statusEl.textContent = 'Location detected successfully';
                coordsEl.textContent = `Latitude: ${lat.toFixed(6)}, Longitude: ${lng.toFixed(6)} (±${Math.round(accuracy)}m)`;
            }, function(err) {
                statusEl.className = 'status error';
                statusEl.textContent = 'Location unavailable - defaulting to India view';
                map.setView([20.5937, 78.9629], 5);
            }, { enableHighAccuracy: true, timeout: 10000 });
        } else {
            statusEl.className = 'status error';
            statusEl.textContent = 'Geolocation not supported';
            map.setView([20.5937, 78.9629], 5);
        }

        // Helper: parse coordinates input
        function parseCoordinates(input) {
            const parts = input.trim().split(',');
            if (parts.length === 2) {
                const lat = parseFloat(parts[0].trim());
                const lng = parseFloat(parts[1].trim());
                if (!isNaN(lat) && !isNaN(lng)) return { lat, lng };
            }
            return null;
        }

        // Geocode using Nominatim
        async function geocodeAddress(address) {
            try {
                const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
                const data = await resp.json();
                if (data && data.length) return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon), display_name: data[0].display_name };
                return null;
            } catch (e) {
                console.error('Geocode error', e);
                return null;
            }
        }

        // OSRM routing
        async function getRoute(start, end) {
            try {
                const url = `https://router.project-osrm.org/route/v1/driving/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson`;
                const resp = await fetch(url);
                const data = await resp.json();
                if (data.code === 'Ok' && data.routes && data.routes.length) return data.routes[0];
                return null;
            } catch (e) {
                console.error('Routing error', e);
                return null;
            }
        }

        // Haversine distance (km)
        function haversineKm(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI/180;
            const dLon = (lon2 - lon1) * Math.PI/180;
            const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function formatDistance(meters) {
            if (meters < 1000) return Math.round(meters) + ' m';
            return (meters/1000).toFixed(2) + ' km';
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds/3600);
            const minutes = Math.floor((seconds%3600)/60);
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes} min`;
        }

        // Clear route
        function clearRoute() {
            if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
            if (sourceMarker && sourceMarker !== currentMarker) { map.removeLayer(sourceMarker); sourceMarker = null; }
            if (destinationMarker) { map.removeLayer(destinationMarker); destinationMarker = null; }
            routeInfo.style.display = 'none';
            sourceInput.value = '';
            destinationInput.value = '';
        }

        // Clear station markers
        function clearStations() {
            stationMarkers.forEach(m => map.removeLayer(m));
            stationMarkers = [];
            stationsPanel.style.display = 'none';
            stationsList.innerHTML = '';
        }

        // Process and display stations (accepts array of station objects)
        function processAndDisplayStations(stationsArray, referenceLocation=null, title='EV Charging Stations') {
            clearStations();
            if (!stationsArray || stationsArray.length === 0) {
                stationsList.innerHTML = '<p style="margin-top:8px;">No stations to display.</p>';
                stationsPanel.style.display = 'block';
                statusEl.className = 'status error';
                statusEl.textContent = 'No stations found';
                return;
            }

            stationsArray.forEach((station, idx) => {
                const lat = Number(station.lattitude ?? station.latitude ?? station.lat);
                const lng = Number(station.longitude ?? station.lon ?? station.lng);
                const name = station.name || station.station_name || 'Unknown Station';
                const state = station.state || station.region || '';
                const city = station.city || station.town || '';
                const address = station.address || station.addr || '';

                let distanceKm = null;
                if (referenceLocation) {
                    distanceKm = haversineKm(referenceLocation.lat, referenceLocation.lng, lat, lng);
                }

                const marker = L.marker([lat, lng], { icon: evIcon }).addTo(map);
                const popupHtml = `
                    <div style="min-width:240px;">
                        <b>${name}</b><br>
                        ${state ? state + ' • ' : ''}${city ? city + '<br>' : ''}
                        ${address ? address + '<br>' : ''}
                        ${distanceKm !== null ? ('Distance: ' + (distanceKm*1000).toFixed(0) + ' m') : ''}
                        <div style="margin-top:8px;"><button onclick="navigateToStation(${lat}, ${lng}, '${name.replace(/'/g, "\\'") }')" style="padding:6px 10px; background: rgba(33,128,141,1); color:white; border:none; border-radius:6px; cursor:pointer;">Navigate Here</button></div>
                    </div>
                `;
                marker.bindPopup(popupHtml);
                stationMarkers.push(marker);
            });

            // Fit map to markers
            const group = L.featureGroup(stationMarkers);
            if (stationMarkers.length) map.fitBounds(group.getBounds(), { padding: [40,40] });

            // Show list sorted by straight-line distance (if referenceLocation provided)
            let listHTML = '<div style="margin-top:8px;">';
            let stationsSorted = stationsArray.slice();
            if (referenceLocation) {
                stationsSorted.sort((a,b) => {
                    const da = haversineKm(referenceLocation.lat, referenceLocation.lng, Number(a.lattitude||a.latitude||a.lat), Number(a.longitude||a.lon||a.lng));
                    const db = haversineKm(referenceLocation.lat, referenceLocation.lng, Number(b.lattitude||b.latitude||b.lat), Number(b.longitude||b.lon||b.lng));
                    return da - db;
                });
            }

            stationsSorted.slice(0, 100).forEach((station, idx) => {
                const lat = Number(station.lattitude ?? station.latitude ?? station.lat);
                const lng = Number(station.longitude ?? station.lon ?? station.lng);
                const name = station.name || station.station_name || 'Unknown Station';
                const distKm = referenceLocation ? haversineKm(referenceLocation.lat, referenceLocation.lng, lat, lng) : null;
                listHTML += `
                    <div style="padding:8px; margin:4px 0; background: rgba(33,128,141,0.05); border-radius:6px; cursor:pointer;" onclick="map.setView([${lat}, ${lng}], 16);">
                        <strong>${name}</strong><br>
                        <small>${station.state||''} ${station.city? '• ' + station.city: ''} ${distKm !== null ? ' • ' + (distKm*1000).toFixed(0) + ' m' : ''}</small>
                    </div>
                `;
            });

            listHTML += '</div>';
            stationsList.innerHTML = `<strong>${title} (${stationsArray.length})</strong>` + listHTML;
            stationsPanel.style.display = 'block';
            statusEl.className = 'status success';
            statusEl.textContent = `Found ${stationsArray.length} stations`;
        }

        // Find stations within radiusKm of a point (from loaded CSV)
        function filterStationsWithinRadius(center, radiusKm) {
            return stationsData.filter(s => {
                const lat = Number(s.lattitude ?? s.latitude ?? s.lat);
                const lng = Number(s.longitude ?? s.lon ?? s.lng);
                if (isNaN(lat) || isNaN(lng)) return false;
                const d = haversineKm(center.lat, center.lng, lat, lng);
                return d <= radiusKm;
            });
        }

        // Compute minimum distance (meters) from a point to a polyline (array of [lat,lng])
        // Uses simple equirectangular projection for local distances — good enough for 1km buffer checks
        function pointToPolylineDistanceMeters(point, polyline) {
            // convert degrees to meters approx
            const R = 6371000;
            const toRad = Math.PI/180;
            const lat0 = point.lat * toRad;
            const lon0 = point.lng * toRad;

            let minDist = Infinity;
            for (let i = 0; i < polyline.length - 1; i++) {
                const a = { lat: polyline[i][0], lng: polyline[i][1] };
                const b = { lat: polyline[i+1][0], lng: polyline[i+1][1] };

                // Project to 2D plane using equirectangular projection around point
                const x1 = (a.lng - point.lng) * Math.cos((a.lat + point.lat) * toRad / 2) * R * toRad;
                const y1 = (a.lat - point.lat) * R * toRad;
                const x2 = (b.lng - point.lng) * Math.cos((b.lat + point.lat) * toRad / 2) * R * toRad;
                const y2 = (b.lat - point.lat) * R * toRad;
                const x0 = 0, y0 = 0; // point at origin

                const dx = x2 - x1;
                const dy = y2 - y1;
                const len2 = dx*dx + dy*dy;
                let t = 0;
                if (len2 > 0) t = ((-x1)*dx + (-y1)*dy) / len2;
                t = Math.max(0, Math.min(1, t));
                const projX = x1 + t*dx;
                const projY = y1 + t*dy;
                const dist = Math.sqrt((projX - x0)**2 + (projY - y0)**2);
                if (dist < minDist) minDist = dist;
            }
            return minDist; // meters
        }

        // Find stations along route within bufferKm (1km) of routeCoordinates (array of [lat,lng])
        async function findStationsAlongRoute(routeCoordinates, bufferKm) {
            const bufferMeters = bufferKm * 1000;
            const filtered = [];
            // routeCoordinates are [lng,lat] in OSRM; convert to [lat,lng]
            const polyline = routeCoordinates.map(c => [c[1], c[0]]);
            for (const s of stationsData) {
                const lat = Number(s.lattitude ?? s.latitude ?? s.lat);
                const lng = Number(s.longitude ?? s.lon ?? s.lng);
                if (isNaN(lat) || isNaN(lng)) continue;
                const distMeters = pointToPolylineDistanceMeters({ lat, lng }, polyline);
                if (distMeters <= bufferMeters) filtered.push(s);
            }

            // Sort by approximate distance along route from start: compute haversine distance from route start to station and sort
            const start = { lat: polyline[0][0], lng: polyline[0][1] };
            filtered.sort((a,b) => {
                const da = haversineKm(start.lat, start.lng, Number(a.lattitude||a.latitude||a.lat), Number(a.longitude||a.lon||a.lng));
                const db = haversineKm(start.lat, start.lng, Number(b.lattitude||b.latitude||b.lat), Number(b.longitude||b.lon||b.lng));
                return da - db;
            });
            return filtered;
        }

        // Navigation function
        async function navigate() {
            const sourceValue = sourceInput.value.trim();
            const destinationValue = destinationInput.value.trim();
            if (!destinationValue) { alert('Please enter a destination location'); return; }
            navigateBtn.disabled = true; navigateBtn.textContent = 'Loading...';

            try {
                // clear previous route
                if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
                if (destinationMarker) { map.removeLayer(destinationMarker); destinationMarker = null; }
                if (sourceMarker && sourceMarker !== currentMarker) { map.removeLayer(sourceMarker); sourceMarker = null; }

                // Resolve source
                let sourceLocation;
                if (!sourceValue) {
                    if (!userLocation) { alert('Current location not available. Please enter a source location.'); return; }
                    sourceLocation = userLocation;
                    if (currentMarker) sourceMarker = currentMarker;
                } else {
                    sourceLocation = parseCoordinates(sourceValue);
                    if (!sourceLocation) {
                        const geocoded = await geocodeAddress(sourceValue);
                        if (!geocoded) { alert('Could not find source location'); return; }
                        sourceLocation = { lat: geocoded.lat, lng: geocoded.lng };
                    }
                    sourceMarker = L.marker([sourceLocation.lat, sourceLocation.lng], { icon: greenIcon }).addTo(map).bindPopup('<b>Source</b>');
                }

                // Resolve destination
                let destinationLocation = parseCoordinates(destinationValue);
                if (!destinationLocation) {
                    const geocoded = await geocodeAddress(destinationValue);
                    if (!geocoded) { alert('Could not find destination location'); return; }
                    destinationLocation = { lat: geocoded.lat, lng: geocoded.lng };
                }
                destinationMarker = L.marker([destinationLocation.lat, destinationLocation.lng], { icon: redIcon }).addTo(map).bindPopup('<b>Destination</b>');

                // Get route from OSRM
                const route = await getRoute(sourceLocation, destinationLocation);
                if (route) {
                    const coordinates = route.geometry.coordinates; // [lng,lat]
                    const latlngs = coordinates.map(c => [c[1], c[0]]);
                    routeLine = L.polyline(latlngs, { color: 'rgba(33,128,141,1)', weight:4, opacity:0.8 }).addTo(map);
                    map.fitBounds(routeLine.getBounds(), { padding: [50,50] });

                    routeInfo.innerHTML = `\n                        <strong>Route Information:</strong><br>\n                        Distance: ${formatDistance(route.distance)}<br>\n                        Estimated Duration: ${formatDuration(route.duration)}\n                    `;
                    routeInfo.style.display = 'block';

                    // Find stations along route within 1km buffer
                    statusEl.className = 'status loading';
                    statusEl.textContent = 'Finding stations along route...';
                    const stationsAlong = await findStationsAlongRoute(coordinates, 1);
                    processAndDisplayStations(stationsAlong, sourceLocation, 'Stations Along Route');

                } else {
                    // fallback straight line
                    const straight = [[sourceLocation.lat, sourceLocation.lng], [destinationLocation.lat, destinationLocation.lng]];
                    routeLine = L.polyline(straight, { color: 'rgba(33,128,141,1)', weight:4, opacity:0.8, dashArray: '10,10' }).addTo(map);
                    map.fitBounds(routeLine.getBounds(), { padding: [50,50] });
                    const distanceKm = haversineKm(sourceLocation.lat, sourceLocation.lng, destinationLocation.lat, destinationLocation.lng);
                    routeInfo.innerHTML = `<strong>Direct Distance:</strong> ${distanceKm.toFixed(2)} km<br><em>Note: Route not available, showing straight line</em>`;
                    routeInfo.style.display = 'block';
                    // also attempt stations along straight line by converting to coordinates
                    const coords = [[sourceLocation.lng, sourceLocation.lat], [destinationLocation.lng, destinationLocation.lat]];
                    const stationsAlong = await findStationsAlongRoute(coords, 1);
                    processAndDisplayStations(stationsAlong, sourceLocation, 'Stations Along Route (approx)');
                }
            } catch (e) {
                console.error('Navigation error', e);
                alert('An error occurred while calculating the route');
            } finally {
                navigateBtn.disabled = false; navigateBtn.textContent = 'Get Directions';
            }
        }

        // Navigate to station from current location
        window.navigateToStation = async function(lat, lng, name) {
            if (!userLocation) { alert('Current location not available'); return; }
            if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
            if (destinationMarker) { map.removeLayer(destinationMarker); destinationMarker = null; }
            destinationMarker = L.marker([lat, lng], { icon: redIcon }).addTo(map).bindPopup(`<b>Destination: ${name}</b>`).openPopup();
            const route = await getRoute(userLocation, { lat, lng });
            if (route) {
                const coordinates = route.geometry.coordinates.map(c => [c[1], c[0]]);
                routeLine = L.polyline(coordinates, { color: 'rgba(33,128,141,1)', weight:4, opacity:0.8 }).addTo(map);
                map.fitBounds(routeLine.getBounds(), { padding:[50,50] });
                routeInfo.innerHTML = `<strong>Route to ${name}:</strong><br>Distance: ${formatDistance(route.distance)}<br>Estimated Duration: ${formatDuration(route.duration)}`;
                routeInfo.style.display = 'block';
            } else {
                const straight = [[userLocation.lat, userLocation.lng], [lat, lng]];
                routeLine = L.polyline(straight, { color:'rgba(33,128,141,1)', weight:4, opacity:0.8, dashArray:'10,10' }).addTo(map);
                map.fitBounds(routeLine.getBounds(), { padding:[50,50] });
                const d = haversineKm(userLocation.lat, userLocation.lng, lat, lng);
                routeInfo.innerHTML = `<strong>Direct Distance to ${name}:</strong> ${d.toFixed(2)} km<br><em>Route not available, showing straight line</em>`;
                routeInfo.style.display = 'block';
            }
        };

        // Find nearby stations (from CSV dataset)
        async function findNearbyStations() {
            findNearbyBtn.disabled = true; findNearbyBtn.textContent = 'Loading...';
            try {
                let searchValue = nearbySearchInput.value.trim();
                let searchLocation;
                if (!searchValue) {
                    if (!userLocation) { alert('Current location not available. Please enter a location.'); return; }
                    searchLocation = userLocation;
                } else {
                    searchLocation = parseCoordinates(searchValue);
                    if (!searchLocation) {
                        const geocoded = await geocodeAddress(searchValue);
                        if (!geocoded) { alert('Could not find the specified location'); return; }
                        searchLocation = { lat: geocoded.lat, lng: geocoded.lng };
                    }
                }

                // center map
                map.setView([searchLocation.lat, searchLocation.lng], 13);

                const nearby = filterStationsWithinRadius(searchLocation, 5); // 5 km
                processAndDisplayStations(nearby, searchLocation, 'Nearby Stations (5km)');
            } catch (e) {
                console.error('Error finding nearby stations', e);
                alert('Error finding nearby stations.');
            } finally {
                findNearbyBtn.disabled = false; findNearbyBtn.textContent = 'Find Nearby Stations (5km)';
            }
        }

        // Show all stations in India
function showAllIndiaStations() {
    // UI : Loading state
    findAllIndiaBtn.disabled = true;
    findAllIndiaBtn.textContent = 'Loading...';
    statusEl.className = '';
    statusEl.textContent = '';

    try {
        if (!stationsData || stationsData.length === 0) {
            throw new Error("Dataset is empty or not loaded");
        }

        // Plot stations & get the count of valid markers
        const displayedCount = processAndDisplayStations(
            stationsData,
            { lat: 20.5937, lng: 78.9629 },
            'All Stations in India'
        );

        statusEl.className = 'status success';
        statusEl.textContent =
            `Dataset contains ${stationsData.length} stations, ` +
            `displayed ${displayedCount} valid stations on map`;

    } catch (e) {
        console.error("Display Error:", e);
        alert('Error displaying EV stations on map.');
        statusEl.className = 'status error';
        statusEl.textContent = 'Failed to display stations — see console for details';

    } finally {
        findAllIndiaBtn.disabled = false;
        findAllIndiaBtn.textContent = 'Show All Stations in India';
    }
}


        // Load CSV data on init
        async function loadStationsCSV() {
            statusEl.className = 'status loading';
            statusEl.textContent = 'Loading station dataset...';
            try {
                const resp = await fetch('ev-charging-stations-india.csv');
                const text = await resp.text();
                const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
                stationsData = parsed.data.map(row => {
                    // normalize keys
                    return Object.assign({}, row, {
                        lattitude: row.lattitude || row.latitude || row.lat,
                        longitude: row.longitude || row.lon || row.lng
                    });
                });
                statusEl.className = 'status success';
                statusEl.textContent = `Loaded ${stationsData.length} stations`; 
            } catch (e) {
                console.error('CSV load error', e);
                statusEl.className = 'status error';
                statusEl.textContent = 'Failed to load stations dataset';
            }
        }

        // Event listeners
        navigateBtn.addEventListener('click', navigate);
        clearRouteBtn.addEventListener('click', clearRoute);
        findNearbyBtn.addEventListener('click', findNearbyStations);
        findAllIndiaBtn.addEventListener('click', showAllIndiaStations);
        clearStationsBtn.addEventListener('click', clearStations);

        // Allow Enter key to trigger actions
        destinationInput.addEventListener('keypress', function(e) { if (e.key === 'Enter') navigate(); });
        nearbySearchInput.addEventListener('keypress', function(e) { if (e.key === 'Enter') findNearbyStations(); });

        // Initialize app
        (async function init() {
            await loadStationsCSV();
            statusEl.className = 'status success';
            statusEl.textContent = 'Ready';
        })();
    </script>
</body>
</html>
